# 1.作用
指定Bean的作用域 ，默认的是singleton，常用的还有prototype
- Spring在注册bean的时候。会通过bean的作用域来决定是否使用代理模式去创建bean。
- 如果是单例模式，那么不会使用代理，非单例就会使用。并且如果这个bean实现了接口，就会使用JDK动态代理，如果继承类，就会使用Cglib代理

# 2.相关注解(spring-web包下)
- `@ApplicationScope`：@Scope用于生命周期绑定到当前 Web 应用程序的组件，`@Scope("application")`
- `@RequestScope`：`@Scope("request")`
- `@SessionScope`：`@Scope("session")`

# 3.相关类/接口
- ScopeMetadata：Scope元数据
    - scopeName：singleton
    - scopedProxyMode：范围代理模式，默认NO
- ScopedProxyMode：范围代理模式
    - DEFAULT/NO/Interface(jdk动态代理)/TARGET_CLASS(Cglib代理)
- ScopedProxyCreator：范围代理创建器，内部委托工厂类ScopedProxyUtils创建代理Bean定义
    - 直接Register：在AnnotatedBeanDefinitionReader中调用
    - ComponentScan方式：在ClassPathBeanDefinitionScanner调用
- ScopedProxyUtils：用于创建作用域代理的实用程序类
    - ScopedProxyFactoryBean:ScopedProxyFactory工厂
    - ScopedObject：Scope对象接口
- ScopeMetadataResolver：Scope解析器接口
    - AnnotationScopeMetadataResolver：@Scope解析器类
        - 主要在resolveScopeMetadata方法中解析BeanDefinition并返回ScopeMetadata元数据
    - Jsr330ScopeMetadataResolver：符合标准 JSR-330 的scope解析器（支持javax.inject.Scope）

# 4.相关调用流程
- AnnotatedBeanDefinitionReader::doRegisterBean(主要处理方法)
- AnnotationScopeMetadataResolver::resolveScopeMetadata：解析@Scope注解元数据
- AnnotationConfigUtils::applyScopedProxyMode：获取代理Bean定义

# 5.主要方法
```java
public class AnnotationScopeMetadataResolver implements ScopeMetadataResolver {
    @Override
    public ScopeMetadata resolveScopeMetadata(BeanDefinition definition) {
        ScopeMetadata metadata = new ScopeMetadata();
         //是否注解类型bean
        if (definition instanceof AnnotatedBeanDefinition) {
             //获取Bean定义
            AnnotatedBeanDefinition annDef = (AnnotatedBeanDefinition) definition;
             //AnnotationConfigUtils 根据AnnotationTypeMetadata获取对应注解属性
            AnnotationAttributes attributes = AnnotationConfigUtils.attributesFor(annDef.getMetadata(), Scope.class);
            if (attributes != null) {
                 //scope中的value配置
                metadata.setScopeName(attributes.getString("value"));
                 //解析Scope注解中的ScopedProxyMode 配置，默认为DEFAULT
                ScopedProxyMode proxyMode = attributes.getEnum("proxyMode");
                //未手动设置时使用默认模式
                if (proxyMode == ScopedProxyMode.DEFAULT) {
                    proxyMode = this.defaultProxyMode;
                }
                metadata.setScopedProxyMode(proxyMode);
            }
        }
        return metadata;
    }
 }
```

