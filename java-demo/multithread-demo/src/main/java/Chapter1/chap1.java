package Chapter1;

public class chap1 {
	/**第一章：多线程基础
	 * 
	 * -----------基础测试----------------
	 * 1_1: 调用的随机性测试
	 * 1_2: 线程的随机性测试
	 * 1_3: 线程不确定性：调用Start方法顺序不是线程执行顺序
	 * 1_4: 线程的另一种实现方式：实现runnable接口
	 * 
	 * -----------线程安全----------------
	 * 1_5: 线程间：数据不共享
	 * 1_6: 数据共享：非线程安全，两个线程同时对数据处理
	 * 1_7: 数据共享：synchornized排队处理，线程安全
	 * 				 synchornized也可以修饰servlet中的方法
	 * 1_8: i--与println合用没用synchornized时出现非线程安全
	 * 
	 * -----------常用方法----------------
	 * 1_9: currentThread()方法：返回代码段正在被哪个线程调用
	 * 1_10: this.getName()与thread.currentThread.getName()的区别
	 * 1_11：isAlive()方法：判断线程是否处于活动状态
	 * 1_12: isAlive()的复杂情况，this.isAlive()
	 * 1_13: sleep()方法，使this.currentThread()(正在执行的线程)休眠指定毫秒
	 * 1_14: getId()方法，获取线程的唯一标识
	 * 
	 * -----------线程中断与判断----------------
	 * 1_15: 线程停止标记：Thread.interrupt()停止标记，无法停止线程
	 * 1_16: this.interrupted():判断当前线程（运行该方法的线程）是否中断，
	 * 					执行后 清除 中断标记，静态方法
	 * 1_17: this.isInterrupted():非静态方法，测试线程对象（非当前线程）是否中断，
	 * 					但不清除中断状态标记
	 * 
	 * -----------线程停止三种方法----------------
	 * 1_18: 异常法停止线程（推荐使用）throw new InterruptException
	 * 1_19: 在sleep()状态下使用interrput() 或相反，抛出异常从而停止线程（推荐使用）
	 * 1_20: stop()方法暴力停止（不推荐使用） stop方法已不再使用
	 * 1_21: interrupt()与return结合使用实现停止线程（可以使用）
	 * 
	 * -----------线程暂停与恢复----------------
	 * 1_22: 暂停线程：suspend()挂起，resume()恢复     (过期作废仍可使用的方法)
	 * 1_23: suspend()与resume()缺点一：独占（公共同步对象，独占锁等）
	 * 1_24: suspend()与resume()缺点二：导致数据不同步
	 * 1_25: yield()方法：使线程放弃当前CPU资源，将它让给其他任务去占用cpu执行时间
	 * 					但放弃的时间不确定，可能刚放弃又获得时间片了。
	 * 
	 * -----------线程优先级----------------
	 * 1_26: 线程优先级的继承性
	 * 1_27: 线程优先级的规则性
	 * 1_28: 线程优先级的随机性
	 * 1_29: 线程优先级高运行得快
	 * 
	 * -----------守护线程----------------
	 * 1_30：守护线程与用户线程
	 * 
	 */
}
