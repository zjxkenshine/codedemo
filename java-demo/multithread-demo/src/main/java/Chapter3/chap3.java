package Chapter3;

public class chap3 {
	/**第三章：线程间通信
	 * 
	 * -----------等待/通知机制----------------
	 * 3_01: 不使用等待/通知机制实现线程通信
	 * 3_02: 等待/通知机制的实现（wait/notify方法）*
	 * 3_03: 方法wait()锁释放与notify()锁不释放
	 * 3_04: interrupt方法遇到wait方法
	 * 3_05: 调用方法notify一次只能通知一个线程并唤醒，notifyAll通知所有
	 * 3_06: wait(long)方法的使用
	 * 3_07: 通知过早
	 * 3_08: 等待wait的条件发生变化
	 * 
	 * -----------生产者/消费者模式的实现----------------
	 * 3_09: 一生产者与一消费者：【操作值】
	 * 3_10: 多生产与多消费：【操作值】---出现假死
	 * 3_11: 一生产与一消费：【操作栈】
	 * 3_12: 一生产与多消费：【操作栈】---解决条件改变与假死
	 * 3_13: 多生产与一消费：【操作栈】
	 * 3_14: 多生产与多消费：【操作栈】
	 * 
	 * -----------管道通信及交叉备份----------------
	 * 3_15: 通过管道进行线程间通信：字节流 byte
	 * 3_16： 通过管道进行线程间通信：字符流char
	 * 3_17： 实战：等待/通知交叉备份
	 * 
	 * -----------join方法----------------
	 * 3_18: 学习join前的铺垫
	 * 3_19: 使用join()方法
	 * 3_20: 方法join与interrupt异常
	 * 3_21: 方法join(long)的使用
	 * 3_22: join(long)与sleep(long)的区别
	 * 3_23: 方法join()后面的代码提前运行：出现意外及解释
	 * 
	 * -----------类ThreadLocal的使用----------------
	 * 3_24: get()方法与null 
	 * 3_25: 验证线程变量的隔离性
	 * 3_26: 解决get返回初始值为null的问题
	 * 3_27: 验证多个线程的初始值
	 * 
	 * -----------类InheritableThreadLocal的使用----------------
	 * 3_28: InheritableThreadLocal值继承
	 * 3_29: 值继承再修改
	 * 
	 * 
	 */
	

}
