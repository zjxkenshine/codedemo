# 1.选择排序
- Test02_SelectionSort
- 时间复杂度O(n^2)
- num：2 5 4 3 1
- 位置：1 2 3 4 5 ... n

流程：
- t1：1和2~n位置的数依次比较，找到最小的值与1位置交换
    - 1 5 4 3 2
- t2：2和3~n位置的数依次比较，找到最小的值与2位置交换
    - 1 2 4 3 5
- t3：1 2 3 4 5

# 2.冒泡排序
- Test03_BubbleSort
- 时间复杂度O(n^2)
- num：2 5 4 3 1
- 位置：1 2 3 4 5 ... n

流程：
- t1：12位置比较，1>2则交换;23位置比较，2>3则交换;以此类推，直到n，最大数会被放到n
    - 2 5 4 3 1
    - (2 5) 4 3 1
    - 2 (4 5) 3 1
    - 2 4 (3 5) 1
    - 2 4 3 (1 5)
- t2：12位置比较，1>2则交换;23位置比较，2>3则交换;以此类推，直到n-1，最大数会被放到n-1
- 以此类推

# 3.插入排序
类似打扑克，插入一张牌并排序
- 时间复杂度O(n^2)
- num：2 5 4 3 1
- 位置：1 2 3 4 5 ... n

流程：
- t1：仅排序第一个数
    - (2) 5 4 3 1
- t2：排序前两个数
    - (2 5) 4 3 1
- t3：排序前三个数
    - (2 4 5) 3 1
- t4：排序前四个数 3往前挪
    - (2 4 3 5) 1
    - (2 3 4 5) 1
- t5：排序前5个数

# 4.二分法
一次查找一半，总共N个数，时间复杂度为N(logN)

- 在一个有序数组中，查找某个数是否存在
- 在一个有序数组中，找>=某个数最左侧的位置
- 局部最小值问题

## 4.1 二分查找
1 2 3 4 5 中查找2
- 二分 3>2，查找左侧 1,2,3
- 再二分 2，找到数据

# 4.2 二分查找>=某个数最左侧的位置
12233344455 找到大于n的最左侧的数 n为3
- (122333)44455 
- 122(333)44455
- 122(33)344455
- 1223(3)344455

# 4.3 局部最小值
数组中所有数无序，相邻数一定不相等
- 局部最小值：
    - i位置的值比两边的值小，arr[i-1]>arr[i]<arr[i+1]
    - 数据呈现V字型排列
- 流程：43212345678910
- 432123(4)5678910
- 432(1)2345678910

# 5. 对数器
一个测试工具，用于测试算法，详细参考Test02_SelectionSort中的main方法
- 循环很多次
- 每次生成随机长度和数值的数组
- 写一个自己的算法 Sa
- 写一个工具提供的算法 Sb
- 每次循环两个算法 Sa 和 Sb 结果相同

# 6. 递归
递归求时间复杂度，master公式：
- `T(N) = a*T(N/b)+O(N^d)`
- a为子问题数量，T(N/b) 为子问题规模，O(N^d) 每次的时间复杂度
- log(b,a) > d -> 复杂度为O(N^log(b,a))
- log(b,a) = d -> 复杂度为O(N^d * logN)
- log(b,a) < d -> 复杂度为O(N^d)

# 7. 归并排序 
- 2 5 4|3 1 6
- 左右排序(递归，子归并排序)
    ```
    2 4 5|1 3 6
    ↑     ↑
    a     b
    ```
- 新开一个数组arr，分别对比a和b的值，小的值放入新数组中，并将指针右移，以此类推 
    ```
    2 4 5|1 3 6
    ↑       ↑
    a       b
    
    arr: 1

    2 4 5|1 3 6
      ↑     ↑
      a     b
    
    arr: 1 2
    ```
- 后续略：最后将arr数组复制回原数组
- 注意需要考虑边界情况，一边越界则将另一边后面所有数据拷贝到arr后面
- 复杂度：使用master公式计算
    - 每次一半的数，T(N/2)，分为两份2，将两边数据拷贝到数组耗时为O(N)
    - 总时间：2*T(N/2)+O(N)
    - a=2,b=2,d=2，log(b,a) = d，时间复杂度为O(N*logN)，参考递归笔记
    - 空间复杂度为O(N)
- 归并排序扩展：
    - 小和问题：Test08_SmallSum
    - 逆序对问题：Test09_ReversePair

# 8.快速排序
快排基础：
- 1.数组分区问题：给定一个数组arr，和一个数num，请把小于等于num的数放在数组的左边，大于num的数放在数组的右边。要求额外空间复杂度O(1)，时间复杂度O(N)
    - Test10_SmallNumLeft
- 2.荷兰国旗问题：Test11_DutchNationalFlag

快速1.0版本
- 数组分区问题扩展
- 3 6 5 3 1 4  每次只选择最右一个数作为num，<num的放在左边，>num的放在右边
- 【<=4区域】 4 【>4区域】   第一趟
-  <=4区域递归  4   >4区域递归   每次只选择该区域最后一个数，将<=num的数放在左边,>num的数放在右边
- 向下递归，直到所有数都排好须

快排2.0版本
- 荷兰国旗问题扩展
- 3 6 5 3 1 4 1 2 3 4 6 5 数组，第一趟，取数组最后一个数5，将小于5的数放在最左边，等于5的数放中间，>5的数放右边
- 【<5区域】5 5 5【>5区域】
- 两边区域用同一种方式分区，直到最终有序

快排1.0和2.0时间复杂度：
- 最差情况O(N^2),如 1 2 3 4 5 6 7 8 这种情况，划分的区域不平均
- 使用master公式计算时间复杂度
    - 左侧规模+右侧规模+O(N)

快排3.0版本
- 随机选一个数做划分，无法确定最好情况和最坏情况，都是等概率事件
- 时间复杂度(Ologn)


