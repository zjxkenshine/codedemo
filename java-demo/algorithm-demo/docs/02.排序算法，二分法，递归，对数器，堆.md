# 1.选择排序
- Test02_SelectionSort
- 时间复杂度O(n^2)
- num：2 5 4 3 1
- 位置：1 2 3 4 5 ... n

流程：
- t1：1和2~n位置的数依次比较，找到最小的值与1位置交换
    - 1 5 4 3 2
- t2：2和3~n位置的数依次比较，找到最小的值与2位置交换
    - 1 2 4 3 5
- t3：1 2 3 4 5

# 2.冒泡排序
- Test03_BubbleSort
- 时间复杂度O(n^2)
- num：2 5 4 3 1
- 位置：1 2 3 4 5 ... n

流程：
- t1：12位置比较，1>2则交换;23位置比较，2>3则交换;以此类推，直到n，最大数会被放到n
    - 2 5 4 3 1
    - (2 5) 4 3 1
    - 2 (4 5) 3 1
    - 2 4 (3 5) 1
    - 2 4 3 (1 5)
- t2：12位置比较，1>2则交换;23位置比较，2>3则交换;以此类推，直到n-1，最大数会被放到n-1
- 以此类推

# 3.插入排序
类似打扑克，插入一张牌并排序
- 时间复杂度O(n^2)
- num：2 5 4 3 1
- 位置：1 2 3 4 5 ... n

流程：
- t1：仅排序第一个数
    - (2) 5 4 3 1
- t2：排序前两个数
    - (2 5) 4 3 1
- t3：排序前三个数
    - (2 4 5) 3 1
- t4：排序前四个数 3往前挪
    - (2 4 3 5) 1
    - (2 3 4 5) 1
- t5：排序前5个数

# 4.二分法
一次查找一半，总共N个数，时间复杂度为N(logN)

- 在一个有序数组中，查找某个数是否存在
- 在一个有序数组中，找>=某个数最左侧的位置
- 局部最小值问题

## 4.1 二分查找
1 2 3 4 5 中查找2
- 二分 3>2，查找左侧 1,2,3
- 再二分 2，找到数据

# 4.2 二分查找>=某个数最左侧的位置
12233344455 找到大于n的最左侧的数 n为3
- (122333)44455 
- 122(333)44455
- 122(33)344455
- 1223(3)344455

# 4.3 局部最小值
数组中所有数无序，相邻数一定不相等
- 局部最小值：
    - i位置的值比两边的值小，arr[i-1]>arr[i]<arr[i+1]
    - 数据呈现V字型排列
- 流程：43212345678910
- 432123(4)5678910
- 432(1)2345678910

# 5. 对数器
一个测试工具，用于测试算法，详细参考Test02_SelectionSort中的main方法
- 循环很多次
- 每次生成随机长度和数值的数组
- 写一个自己的算法 Sa
- 写一个工具提供的算法 Sb
- 每次循环两个算法 Sa 和 Sb 结果相同

# 6. 递归
递归求时间复杂度，master公式：
- `T(N) = a*T(N/b)+O(N^d)`
- a为子问题数量，T(N/b) 为子问题规模，O(N^d) 每次的时间复杂度
- log(b,a) > d -> 复杂度为O(N^log(b,a))
- log(b,a) = d -> 复杂度为O(N^d * logN)
- log(b,a) < d -> 复杂度为O(N^d)

# 7. 归并排序 
- 2 5 4|3 1 6
- 左右排序(递归，子归并排序)
    ```
    2 4 5|1 3 6
    ↑     ↑
    a     b
    ```
- 新开一个数组arr，分别对比a和b的值，小的值放入新数组中，并将指针右移，以此类推 
    ```
    2 4 5|1 3 6
    ↑       ↑
    a       b
    
    arr: 1

    2 4 5|1 3 6
      ↑     ↑
      a     b
    
    arr: 1 2
    ```
- 后续略：最后将arr数组复制回原数组
- 注意需要考虑边界情况，一边越界则将另一边后面所有数据拷贝到arr后面
- 复杂度：使用master公式计算
    - 每次一半的数，T(N/2)，分为两份2，将两边数据拷贝到数组耗时为O(N)
    - 总时间：2*T(N/2)+O(N)
    - a=2,b=2,d=2，log(b,a) = d，时间复杂度为O(N*logN)，参考递归笔记
    - 空间复杂度为O(N)
- 归并排序扩展：
    - 小和问题：Test08_SmallSum
    - 逆序对问题：Test09_ReversePair

# 8.快速排序
快排基础：
- 1.数组分区问题：给定一个数组arr，和一个数num，请把小于等于num的数放在数组的左边，大于num的数放在数组的右边。要求额外空间复杂度O(1)，时间复杂度O(N)
    - Test10_SmallNumLeft
- 2.荷兰国旗问题：Test11_DutchNationalFlag

快速1.0版本
- 数组分区问题扩展
- 3 6 5 3 1 4  每次只选择最右一个数作为num，<num的放在左边，>num的放在右边
- 【<=4区域】 4 【>4区域】   第一趟
-  <=4区域递归  4   >4区域递归   每次只选择该区域最后一个数，将<=num的数放在左边,>num的数放在右边
- 向下递归，直到所有数都排好须

快排2.0版本
- 荷兰国旗问题扩展
- 3 6 5 3 1 4 1 2 3 4 6 5 数组，第一趟，取数组最后一个数5，将小于5的数放在最左边，等于5的数放中间，>5的数放右边
- 【<5区域】5 5 5【>5区域】
- 两边区域用同一种方式分区，直到最终有序

快排1.0和2.0时间复杂度：
- 最差情况O(N^2),如 1 2 3 4 5 6 7 8 这种情况，划分的区域不平均
- 使用master公式计算时间复杂度
    - 左侧规模+右侧规模+O(N)

快排3.0版本
- 随机选一个数做划分，无法确定最好情况和最坏情况，都是等概率事件
- 时间复杂度(Ologn)

# 9.二叉树
- 数值：3527196
- 下标：0123456
    ```
        0
        /\
       1  2
      /\  /\
     3  45  6
    ```
- size=7
- 左子节点索引：`2*i+1`
- 右子节点索引：`2*i+2`
- 父节点坐标：`(i-1)/2`

二叉树概念：
- 完全二叉树：设二叉树的深度为h，除第 h 层外，其它各层 (1～h-1) 的结点数都达到最大个数，第 h 层所有的结点都连续集中在最左边
- 满二叉树：深度为k且有2^k-1个结点的二叉树称为满二叉树

# 10.堆
堆：首先是完全二叉树，有以下分类
- 大根堆(大顶堆)：树顶点最大
  ```
        6
        /\
       5  4
      /\  /\
     4  33  0
  ```
- 小根堆(小顶堆)：树顶点最小

大根堆插入流程：
  ```
    7           7                       7
   /\          /\                      /\
  6  5 新增7  6  5  与父节点6比较并交换 7  5
 /           /\                      /\    
3           3  7                    3  6
  ```
- 参考代码：Test13_HeapSort

将大根堆中最大值去掉：把6去掉
```
    6
    /\
   3  5
  /\  /
 2  34
```
先将最后的数放到堆顶，返回6，再将最后的数4去掉：
```
     4
    /\
   3  5
  /\  
 2  3
```
4和左右孩子较大的值做比较，比孩子小则交换，没有孩子或比所有孩子大则结束：（这个过程叫做堆化Heapify）
```
     5
    /\
   3  4
  /\  
 2  3
```

复杂度：
- 插入的时间复杂度为O(logN)
- 堆化的时间复杂度为O(logN)

堆排序过程：
- 构建大根堆0~n
- 交换最后的位置和第一的位置，堆化0~n-1的数，最大的数被放到数组最后了
- 重复上面的过程直到剩余堆大小<=2
- 时间复杂度O(n*logn)，空间复杂度O(1)

Java中的堆结构：可以直接使用
- PriorityQueue 优先级队列
- 黑盒方式，不支持细粒度控制，有很多情境下需要手写堆才能实现高效

堆排序扩展：
- Test13_HeapSort
- Test14_HeapSortExtend

# 11.比较器 Comparator接口
参考Test15_Comparator
- 比较器的实质就是重载比较运算符
- 比较器可以很好的应用在特殊标准的排序上
- 比较器可以很好的应用在根据特殊标准排序的结构上

上面的所有排序都是基于比较的排序
- 还有基于桶思想的排序
    - 计数排序
    - 基数排序

# 12.计数排序
参考Test16_CountSort

一个数组中的数只有0~200 arr[....]，给数据排序（统计每个数出现多少次）

思路：
- 新建一个桶（桶可以是数组，队列，栈等任意数据结构），大小为201（词频表）
- 出现哪个数则哪个位置的计数+1
- 将桶中相应位置对应数量的数据取出

# 13.基数排序
17 13 25 100 72
- 最大长度100为3位：将所有数据补齐为3位
- 017 013 025 100 072
- 准备10个桶，0~9号桶，这里的桶为队列，先进先出
- 第一步：将个位数相关的数据放到桶内
    - 0号：100
    - 2号：072
    - 3号：013
    - 5号：025
    - 7号：017
- 然后将桶中数据依次取出：100 072 013 025 017
- 第二步：将十位数相同数据放到桶内
    - 0号：100
    - 1号：013 017
    - 2号：025
    - 7号：072
- 然后将桶中数据依次取出：100 013 017 025 072
- 第三步：将百位数相同的数据放到桶内
    - 0号：013 017 025 072
    - 1号：100
- 然后将桶中数据依次取出：013 017 025 072 100
- 基数排序完毕

代码：
- Test17_RadixSort
- 代码中的count为当前位0~n的数字有多少个

原始数组：013 021 011 052 062 
- 个位数计数数组(不存在)：0 2 2 1 0 0 ...
- 个位数count,词频累加：0 2 4 5 5 5 ...
- 从右往左依次处理：062
    - 2的count为4，表示个位数<=2的数有4个，2的数量有4-2=2个
    - 062放在下标为count[2]-1=3的位置上，然后count--
    - ? ? ? 062 ?
- 处理 052，此时count数组为 0 2 3 5 5 5 ...
    - 2的count为3，放在2位置上，count--
    - ? ? 052 062 ?
- 处理 011，此时count数组为 0 2 2 5 5 5 ...
    - 1的count为2，放在1位置上，count--
    - ? 011 052 062 ?
- 处理 021，此时count数组为 0 1 2 5 5 5 ...
    - 1的count为1，放在0位置上，count--
    - 021 011 052 062 ?
- 处理 013，此时count数组为 0 0 2 5 5 5 ...
    - 3的count为5，放在4位置上
    - 021 011 052 062 013
- 接着处理十位数：以此类推，直到排序完成
